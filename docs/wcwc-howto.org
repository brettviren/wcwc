#+title: How to do various things on WCWC.
#+setupfile: wcwc-setup.org

This document collects various recipes to perform some specific tasks.  It assumes basic understanding of WCWC and the ~wcwc~ command (see [[file:wcwc.org]]) and in some cases assumes the BNL WCWC (see [[file:wcwc-bnl.org]]).  If there is something not here that you think would be useful to add, feel free to reach out to the WCWC admin or make an Issue or PR on the [[https://github.com/brettviren/wcwc][WCWC GitHub]].  

* meta :noexport:

#+begin_src elisp :results none
(setenv "PATH" (concat (getenv "PATH") ":" (expand-file-name "../scripts")))
#+end_src

#+begin_src sh :results output drawer
scp wcwc-howto.html wcwc-howto.pdf hierocles.phy.bnl.gov:public_html/wire-cell/docs/
#+end_src

#+RESULTS:
:results:
:end:

* Listing packages inside a Spack Environment
:PROPERTIES:
:CUSTOM_ID: find-in-env
:END:


When a Spack Environment is "activated", Spack sees only the subset of packages
that have been added to the environment when it was constructed.  Thus the usual ~find~ command may be used.

#+begin_example
$ wcwc shell -e <env-name-or-dir>
$ wcwc find
#+end_example

* Use PyTorch

** The ~py-torch~ spec

In particular ~py-torch~ can require variants to be specified.  In particular with or without CUDA and in some cases the CUDA compute capability (aka CC aka ~cuda_arch~) must be included.  Some typical, though partially specified variants are:

- ~py-torch~cuda~ :: CPU-only build
- ~py-torch+cuda~ :: CPU+GPU build
- ~py-torch+cuda cuda_arch=89~ :: CPU+GPU specifying the nVidia compute capability (CC) version 

Not all CC versions may be available.  CC 8.9 (~89~) covers a large range of hardware (up to 40xx) and software versions (up to 11.x).  See [[file:wcwc-packages.org::#cuda]] for some details.

To see all package instances that are available (but note section [[#find-in-env]]).
#+begin_example
$ wcwc find -lv py-torch
#+end_example
#+begin_src sh :exports results :results output :wrap example
wcwc find -lv py-torch
#+end_src

#+RESULTS:
#+begin_example
-- linux-debian12-x86_64 / gcc@12.2.0 ---------------------------
2dj527f py-torch@2.4.0~caffe2+cuda+cudnn~custom-protobuf~debug+distributed+fbgemm+gloo+kineto~magma~metal+mkldnn+mpi~nccl+numa+numpy+onnx_ml+openmp+qnnpack~rocm+tensorpipe~test~ucc+valgrind+xnnpack build_system=python_pip cuda_arch=89
#+end_example
Specifying an exact instance with the hash may be a useful shorthand: ~py-torch/2dj527f~.


** Environment Module

To use an installed version of ~py-torch~ via an Environment Module:
#+begin_example
$ wcwc shell -l 'py-torch+cuda'
$ python -c 'import torch; print(torch.cuda.is_available())'
True
$ python -c 'import torch; print(torch.cuda.device_count())'
2
#+end_example

** Spack Environment

A Spack Environment with an added instance of ~py-torch~ can be made like:
#+begin_example
$ wcwc env -e py-torch-env "py-torch+cuda cuda_arch=89"
--> In WCWC, activate with: wcwc shell -e wcwc-env

$ wcwc shell -e wcwc-env
$ python -c 'import torch; print(torch.cuda.is_available())'
True
$ python -c 'import torch; print(torch.cuda.device_count())'
2
#+end_example


* Use Spack View to develop WCT
:PROPERTIES:
:CUSTOM_ID: spack-view-wct
:END:

A Spack View is simply a single directory tree that contains all files from a set of installed packages via symlinks.  It forms the kernel of a Spack Environment but it may be used directly without the need for Spack to manage your shell environment settings.  Instead, the tool [[https://direnv.net][direnv]] will supply shell environment management in a simple and transparent way.

This section will walk through creating a View based on an instance of ~wire-cell-toolkit~ for the purpose of fixing a bug in the HDF5 support.  The example can be adapted to produce a view based on other package instances and for other purposes.

** Configure your shell for ~direnv~
:PROPERTIES:
:CUSTOM_ID: configure-direnv
:END:

Follow the simple, one-time instructions here:

https://direnv.net/docs/hook.html

Hooking ~direnv~ into your shell is not required for simply making the view (section [[#create-view]]) but will be needed to use the view (starting with section [[#use-view]]).

** Determine specs to seed the view
:PROPERTIES:
:CUSTOM_ID: view-seeds
:END:

A view is built given one or more instances of packages that are already installed in the general Spack install tree.  We must specify each seed package with an unambiguous "spec".  
The most precise and robust way to do that is to supply the "hash" by which Spack identifies the package instance.  Available hashes for a given package can be discovered with:
#+begin_example
$ wcwc find -lv wire-cell-toolkit
-- linux-debian12-x86_64 / clang@17.0.6 -------------------------
jh6gdsn wire-cell-toolkit@0.28.0~cppjsonnet+cuda+emacs+glpk+hdf+root+tbb+torch build_system=generic cuda_arch=89 cxxstd=17
ghw2if5 wire-cell-toolkit@master~cppjsonnet+cuda~emacs+glpk+hdf+root+tbb+torch build_system=generic cuda_arch=89 cxxstd=17

-- linux-debian12-x86_64 / gcc@12.2.0 ---------------------------
3pzitmq wire-cell-toolkit@master~cppjsonnet+cuda~emacs~glpk~hdf~root+tbb+torch build_system=generic cuda_arch=89 cxxstd=17
q3zolqz wire-cell-toolkit@master~cppjsonnet+cuda~emacs+glpk+hdf+root+tbb+torch build_system=generic cuda_arch=89 cxxstd=17
==> 4 installed packages
#+end_example
We pick the instance built by GCC and with HDF5 support (~+hdf~ not =~hdf= build variant).  That spec is "spelled":
#+begin_example
wire-cell-toolkit/q3zolqz
#+end_example

** Create the view
:PROPERTIES:
:CUSTOM_ID: create-view
:END:

Generically, we create the view with a command like:
#+begin_example
$ wcwc view -S STACK -e EXCLUDE -d TOPDIR -s SEED/HASH TOPDIR/VIEWDIR
#+end_example
For our specific example, the command is:
#+begin_example
$ wcwc view -S wirecell -e wire-cell-toolkit -d hio-fix -s wire-cell-toolkit/q3zolqz hio-fix/local
#+end_example
The explanation of the arguments:
- ~-S/--stacks~ names any WCWC software *stacks* providing required packages.  We name ~wirecell~ as that is what provides ~wire-cell-toolkit~.
- ~-e/--exclude~ we want to *exclude* installation of WCT itself as we will be later installing our own from source.  A simple package name (not a more full spec) must be provided.  Omit this option if you plan to merely use WCT instead of build a development version.  You may start out as a user and convert to a developer, see section [[#convert-user-to-dev]].
- ~-i/--ignore-conflicts~ will *skip* including files that are common to multiple packages.  This is required to ignore conflicts due to packages that pollute common paths, eg ~<view>/README~ files.
- ~-d/--direnv~ defines the top level of a directory tree to be controlled by *direnv*.
- ~./hio-fix/local~ defines the the *view* directory.
#+begin_note
Creating the view can take minute or so.  The worked example here results in over 100k symlinks created across more than 13k directories.
#+end_note

** View tree structure
:PROPERTIES:
:CUSTOM_ID: view-tree
:END:
In section [[#create-view]] we placed the view directory as a subdirectory of the one controlled by ~direnv~.  It produces an initial structure like:
#+begin_example
./hio-fix/.envrc    # the direnv configuration file 
./hio-fix/local/    # the Spack View directory tree
#+end_example
The name ~local/~ is chosen to be reminiscent of the traditional Unix prefix ~/usr/local~.  Like that, the view tree has the usual ~local/{bin,lib,include}~ areas.  This gives us "room" to add WCT and WC Python source in sibling directories (section [[#clone-source]]):
#+begin_example
./hio-fix/toolkit/  # wire-cell-toolkit source
./hio-fix/python/   # wire-cell-python source
#+end_example

** Use the view
:PROPERTIES:
:CUSTOM_ID: use-view
:END:

We can now enter any directory under the top-level one and our shell environment will be automatically set:
#+begin_example
$ cd hio-fix/  
# 1. Allow direnv to apply settings
$ direnv allow
# 2. Examine the direnv configuration file
$ cat .envrc
#+end_example
1. We must "allow" ~direnv~ at least once.  After being allowed, ~direnv~ will remember for the future.  
2. The ~.envrc~ file syntax is essentially that of ~bash~ with some additional commands defined by ~direnv~.  See the [[https://direnv.net/man/direnv-stdlib.1.html][direnv-stdlib(1)]] man page for a list of available commands.  
The shell settings will be automatically undone by ~direnv~ by simply changing directory to be outside this tree:
#+begin_example
$ cd 
#+end_example

** Destroy the view
:PROPERTIES:
:CUSTOM_ID: destroy-view
:END:

When the view is no longer required its directory may simple be removed:
#+begin_example
$ rm -rf hio-fix/local/
#+end_example

You may of course wish to remove the top level directory as well:
#+begin_example
$ rm -rf hio-fix/
#+end_example

** Get the source
:PROPERTIES:
:CUSTOM_ID: clone-source
:END:
We will get the WC-toolkit and WC-python source.  If you are a WC developer with push privileges, you should clone the source via SSH keys using hte ~git@~ URL:
#+begin_example
  $ cd hio-fix/
  $ git clone git@github.com:WireCell/wire-cell-python.git  python
  $ git clone git@github.com:WireCell/wire-cell-toolkit.git toolkit
  $ git clone git@github.com:WireCell/wire-cell-data.git    wcdata
#+end_example
Otherwise, you may use the ~https://~ URLs or fork the package(s) to your own GitHub account and use those URLs.

** Customize ~.envrc~ for WCT
:PROPERTIES:
:CUSTOM_ID: custom-envrc
:END:

The ~wcwc view~ initializes ~.envrc~ as a generic starting point.  Here, we will customize it to provide support specifically for WCT development.  To start with 
#+begin_example
    # Locate the "wire-cell" and other WCT programs.
    PATH_add $PWD/toolkit/build/apps

    # Locate the as-built libraries
    for pkg in apps aux clus gen hio iface img pgraph pytorch root sigproc sig sio tbb util
    do
        path_add LD_LIBRARY_PATH $PWD/toolkit/build/$pkg
    done

    # Locate the "bats" program and configure its load path.
    PATH_add $PWD/toolkit/test/bats/bin
    export BATS_LIB_PATH=$PWD/toolkit/test

    # Locate WCT configuration files.
    path_add WIRECELL_PATH $PWD/toolkit/cfg
#+end_example
The above is generic to any view-based WCT dev setup.  You may simply copy-paste it into your own ~.envrc~.

Finally, we locate the ~wire-cell-data~ contents.  This is often user-specific but with the clone performed above you may include this with::
#+begin_example
  path_add WIRECELL_PATH $PWD/wcdata
#+end_example
In the future, WC "data" configuration files will be provided as a Spack package (see [[https://github.com/WireCell/wire-cell-spack/issues/14][wire-cell-spack/issues/14]]).

#+begin_note
- After any modifications of ~.envrc~ we will be prompted for and must run ~direnv allow~ to authorize the changes.
- Be aware that our custom ~.envrc~ file will be moved aside and replaced if we ever rerun ~wcwc view~.
#+end_note

** Install ~wire-cell-python~
:PROPERTIES:
:CUSTOM_ID: install-wcpython
:END:

Before installing the WCT package we will install the copy of ~wire-cell-python~ that was cloned in section [[#clone-source]].   This package is not strictly required in order to build or use WCT.  However, it provides various useful auxiliary commands and some WCT unit tests can make use of it.
#+begin_example
  $ cd python
  $ pip install -e "."
  $ cd ..
#+end_example
Here we use the standard Python tool ~pip~ to install the package.  Be sure to include the ~"."~ (quotes added for visibility) which tells ~pip~ to consider the package that is in the current working directory.  The ~-e~ is given to allow us to later edit the Python code and have our changes immediately available for running.  The package is installed into the Python virtual environment that ~direnv~ has created for us due to the ~layout python~ line in the ~.envrc~ file.  For this example, the location ~hio-fix/.direnv/python-X.Y.Z/~ is used.

** Configure WCT builder
:PROPERTIES:
:CUSTOM_ID: configure-wct-build
:END:
WCT is built with the provided ~./wcb~ (wire-cell builder) tool.  In WCT, this tool is simply a copy of the plain [[https://waf.io/][waf]] command which can also be used.  


#+begin_example
  $ cd toolkit
  $ ./wcb configure --prefix=$PREFIX \
       --with-cuda=no --with-libtorch=no --with-root=no \
       --boost-mt --boost-libs=$PREFIX/lib --boost-include=$PREFIX/include \
       --with-jsonnet-libs=gojsonnet
#+end_example
Some explanation:
- The ~./wcb --prefix=$PREFIX~ provides a hint to check the prefix for externals.
- The ~--with-*=no~ flags are used to avoid features not required in order reduce build time.
- Boost can not currently be auto-detected in ~$PREFIX~ so we must be explicit (see [[https://github.com/WireCell/wire-cell-toolkit/issues/334][#334]]).
- We say to use the faster Go Jsonnet library instead of the default C++ ~libjsonnet~.

** Build WCT
:PROPERTIES:
:CUSTOM_ID: build-wct
:END:

After configuring the build, we do the build itself in the usual way:
#+begin_example
$ ./wcb
#+end_example
With the ~.envrc~ customization from section [[#custom-envrc]] we may now use the results.
#+begin_example
$ wire-cell --version
$ wire-cell --help
#+end_example


** Installing WCT to view
:PROPERTIES:
:CUSTOM_ID: install-wct
:END:


With the customization to run ~wire-cell~ "in place" from the ~toolkit/build/~ directory, no installation is required.  Nonetheless, we may install WCT in the usual way:
#+begin_example
$ ./wcb install
#+end_example
This will install into the view directory as we configured the builder with ~--prefix=$PREFIX~.

** Post-hoc exclusion of package files from a view
:PROPERTIES:
:CUSTOM_ID: convert-user-to-dev
:END:

When running the ~wcwc view~ command above, we used ~wire-cell-toolkit~ for the seed and we also excluded it with the ~-e/--exclude~ option.  This results in a view that contains all the dependencies for ~wire-cell-toolkit~ but not the files for ~wire-cell-toolkit~ itself.  It is useful to exclude ~wire-cell-toolkit~ files to avoid any confusion between the versions provided by the Spack package instance and the versions we wish to build from our cloned source.

Sometimes we may forget to exclude ~wire-cell-toolkit~ files.  We can simply ~rm~ the entire area but it is often easier to simply remove the WCT files from the view.  This can be done simply with:
#+begin_example
$ rm -rf hio-fix/local/bin/{wire-cell,wc*} \
         hio-fix/local/lib/libWireCell* \
         hio-fix/local/include/WireCell* 
#+end_example

* Add existing package to a Spack Environment

The ~env~ command can simply be rerun.

#+begin_example
$ wcwc env -e test-env
$ wcwc env -e test-env zstd
$ wcwc shell -e test-env "zstd --version"
#+end_example

* Install a novel package to a Spack Environment

t.b.d. (currently broken)
