#+title: Using FreeIPA

* Motivation

Local accounts exist on current workstations and their IDs are not unique.  At the same time we want to allow $N_{users}$ to log into $N_{workstations}$ and creating local accounts does not scale well.  Further, users want to mount their ~$HOME~ from their local workstation to a remote workstation.  NFS will not correctly handle file permissions given the lack of unique user IDs.  Using FreeIPA provides for distributed account management and (may?) provide user ID mapping (if not, we must change local user IDs and file permissions).

The Physics department has a FreeIPA server (Kerberos, LDAP and bells and
whistles) which is already used for SSH gateways and others.  It was used long
ago to provide accounts to summer students on a set of workstations.  
An Ansible  config from that era exists at
#+begin_example
gogs@git.phy.bnl.gov:bv/physics-server-config.git
#+end_example

* User IDs

In principle, it should be relatively painless to adopt FreeIPA.  However, one big sticking point is dealing with user ID clashes.  Two possible solutions: there exists some FreeIPA ID mapping we "simply" make user IDs and file ownerships reflect unique numbering.


** FreeIPA ID mapping

According to [[https://freeipa.readthedocs.io/en/latest/designs/id-mapping.html][the freeipa manual]], an ID range large enough for 5-digit user IDs is the default choice.  It also provides an ~idview~ function to map a FreeIPA UID to the local system POSIX UID.  [[https://www.admin-magazine.com/Archive/2017/38/ID-Views-smooth-migration-to-a-new-identity-management-system][From here]]:

#+begin_example
  # getent passwd foobar
  foobar:*:1225800039:1225800039:Foo Bar:/home/foobar:/bin/bash
  # ipa idview-add --desc "My first Test View" testview
  # ipa idoverrideuser-add --desc "New UID for foobar" --uid 5555 testview foobar
  # ipa idview-apply --hosts gateway.example.com testview
  # getent passwd foobar
  foobar:*:5555:1225800039:Foo Bar:/home/foobar:/bin/bash
#+end_example
Likewise, group.
Sounds exactly what is needed.

** SSSD ID mapping

More locally, a mapping can be applied at the SSSD level.  This will not be known to FreeIPA.

#+begin_example
  # sss_override user-add foobar -u 5555
  # systemctl restart sssd
  # getent passwd foobar
  foobar:*:5555:1225800039:Foo Bar:/home/foobar:/bin/bash
#+end_example
Despite the name "add", this can be used for changing info on existing users.  

** Unique user IDs
#+begin_example
  groupmod -g NEWGID GROUPNAME  
  usermod  -g NEWGID -u NEWUID USERNAME

  chown --from=CURRENT_OWNER:CURRENT_GROUP -R NEW_OWNER:NEW_GROUP DIRECTORY
#+end_example

Any running user processes must likely be stopped to allow ~usermod~ to complete.  Apparently, ~usermod~ doesn't set group on ~$HOME~ so must follow up with ~chown~.

** ID conventions

The [[https://en.wikipedia.org/wiki/Linux_Standard_Base][Linux Standard Base]] simply restricts usage of the IDs below 1000 to the operating system leaving 1000+ unspecified.
If FreeIPA ~idview~ mapping is used, then we do not need to invent a unique user ID convention.

OTOH, if we must make local POSIX user IDs unique then we do.
BNL employee "life" numbers for any likely user are 5 digits and thus make for good user IDs.  However, BNL guests may use WCWC and they have numbers in the form "alpha + 4-digit".  A disambiguation method is needed for them to form the basis of a user ID.  Life numbers are retired and not reused when an employee leaves BNL (thus the "life" description).  Some individuals may subsequently receive a guest number.  It is not known if guest numbers are ever recycled.
