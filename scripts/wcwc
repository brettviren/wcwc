#!/usr/bin/env python
'''
Manage and use elements of a Wire-Cell Workstation Cluster.

It may take a configuration file given explicitly or defaulting to
<prefix>/wcwc.cfg.  The file <prefix>/wcwc.cfg will be rewritten to reflect
changes to the WCWC area under <prefix>/.
'''

default_repos = dict(
    base=dict(url="https://github.com/spack/spack.git", tag="v0.22.1"),
    wirecell=dict(url="https://github.com/WireCell/wire-cell-spack.git", tag="0.28.0.0", upstreams=["base"]),
    nusoft=dict(url="https://github.com/NuSoftHEP/nusofthep-spack-recipes.git", upstreams=["base"]),
    art=dict(url="https://github.com/FNALssi/fnal_art.git", upstreams=["nusoft"]),
    larsoft=dict(url="https://github.com/LArSoft/larsoft-spack-recipes.git", upstreams=["art"]),
    # dune, sbnd, ...
)

# These are lsb_release -ds lines from OSes that should work as WCWC members.
# In principle, WCWC can work on many OSes.  To extend this list, the
# "prepare-os" command would need extending and the typical Spack installations
# used for WCWC applications would need testing.
known_oses=("Debian GNU/Linux 12 (bookworm)",)


import os
import sys
import json
import yaml
import click
import graphlib
import functools
import subprocess
from pathlib import Path
from collections import namedtuple

import logging
log = logging.getLogger("wcwc")
debug = log.debug
info = log.info
warn = log.warn
error = log.error

def call(*cmd, **opts):
    '''
    Run and check command, return stdout.
    '''
    if isinstance(cmd[0], str):
        opts["shell"]=True
    debug(f"call: {cmd} {opts}")
    return subprocess.check_output(*cmd, **opts).decode()


def run(*cmd, **opts):
    '''
    Run a command.  Return successful return code.
    '''
    if isinstance(cmd[0], str):
        opts["shell"]=True
    debug(f"run: {cmd} {opts}")
    got = subprocess.run(*cmd, **opts)
    got.check_returncode()
    return got


def merge_patch(target, patch):
    '''
    Patch target and return result.

    https://datatracker.ietf.org/doc/html/rfc7396

    '''
    if isinstance(patch, dict):
        if not isinstance(target, dict):
            target = dict()
        for k,v in patch.items():
            if v is None:
                if k in target:
                    target.pop(k)
            elif k in target:
                target[k] = merge_patch(target[k], v)
            else:
                target[k] = v
        return target
    return patch


def merge_dicts(dict1, dict2):
    """ Recursively merges dict2 into dict1 """
    if not isinstance(dict1, dict) or not isinstance(dict2, dict):
        return dict2
    for k in dict2:
        if k in dict1:
            dict1[k] = merge_dicts(dict1[k], dict2[k])
        else:
            dict1[k] = dict2[k]
    return dict1


class Config:
    def __init__(self, prefix, config):
        self.prefix = Path(prefix or "/wcwc")
        self.cfg_path = Path(config or self.prefix / "wcwc.yml")
        self.cfg = dict(repos=default_repos)
        if self.cfg_path.exists():
            self.cfg = merge_dicts(self.cfg,
                                   yaml.safe_load(self.cfg_path.read_text()))

    @property
    def repos(self):
        '''Known repo names'''
        return self.cfg["repos"].keys()


    def depgraph(self, *seeds):
        gr = dict()
        for seed in seeds:
            gr[seed] = set(list(self.cfg['repos'][seed].get("upstreams",())))
            gr |= self.depgraph(*gr[seed])
        return gr
            

    def resolve_upstreams(self, *seeds):
        '''
        Resolve upstream dependencies to a flat list.
        '''
        gr = self.depgraph(*seeds)
        return list(graphlib.TopologicalSorter(gr).static_order())


    @functools.cached_property
    def spack_exe(self):
        exe = self.paths("base").root / "repo" / "bin" / "spack"
        if not exe.exists():
            error(f'no spack found at {exe}')
            error('have you run "wcwc install-spack" yet?\n')
            raise click.BadArgumentUsage("no spack found")
        return exe


    def spack(self, *args, runner=run, **kwds):
        '''
        Execute spack.

        If args[0] is a string it is executed as a shell command line.
        O.w. args is a list providing the arguments to the spack command.

        Runner may be "run" or "call".
        '''
        exe = self.spack_exe
        if isinstance(args[0], str):
            return runner(str(exe) + " " + args[0], **kwds)
        return runner([str(exe)] + args, **kwds)


    def save(self):
        self.cfg_path.parent.mkdir(parents=True, exist_ok=True)
        self.cfg_path.write_text(yaml.dump(self.cfg, sort_keys=False))

    def repo(self, name, record=False, **kwds):
        '''
        Return a (git) repo dict with name, possibly overriding with kwds
        '''
        got = dict(self.cfg['repos'].get(name, {}))
        for key in "tag url upstreams".split():
            val = kwds.get(key, None)
            if val is None:
                continue
            got[key] = val
        if record:
            self.cfg['repos'][name] = got
        return got
        
    def assure_yaml(self, path, dat, force=False):
        path = Path(path)
        if path.exists() and not force:
            debug(f'not writing existing file: {path}')
            return
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(yaml.dump(dat, sort_keys=False))
        debug(f'wrote file: {path}')

    def paths(self, name):
        '''
        Return all canonical paths for repo.
        '''
        root = self.prefix / "spack" / name
        more = {k:root/k for k in "scope repo install".split()}
        more['git'] = root / "repo" / ".git"
        if name == "base":
            # Connect with Spack's structure that differs from how WCWC handles
            # others.  "repo" refers to Spack repo not git repo though these two
            # coincide for the "chained" repos.
            more['repo'] = more['repo'] / "var" / "spack" / "repos" / "builtin"
        return namedtuple("Paths", "root scope repo install git")(root=root, **more)


    def assure_repo(self, name, recurs=False, force=False):
        '''
        Assure a repo is configured.
        '''
        self.assure_repo_clone(name, recurs)
        self.assure_repo_scope(name, recurs, force)

    def assure_repo_scope(self, name, recurs=False, force=False):
        '''
        Assure that a repo scope is configured.
        '''
        repo = self.cfg['repos'][name]

        if recurs and repo.get("upstreams", ()):
            for usr in repo['upstreams']:
                self.assure_repo_scope(usr, True)

        paths = self.paths(name)

        def cfg_file(fname, dat):
            self.assure_yaml(paths.scope / fname, dat, force)

        cfg_file("repos.yaml", dict(repos=[str(paths.repo)]))

        config_dat = dict(build_stage=['$user_cache_path/stage'],
                          install_tree=dict(root=str(paths.install)))
        
        ups = repo.get("upstreams", None)
        if ups:
            upstreams = dict()
            for usr in ups:
                upstreams[usr] = dict(install_tree = str(self.paths(usr).install))
                
            #config_dat['upstreams'] = upstreams
            cfg_file("upstreams.yaml", dict(upstreams=upstreams))
            

        if name == "base":
            # Hack: make sure bare spack repo is configured like base.
            if paths.repo.exists():
                # git would get angry if we run this before assure_repo_clone....
                self.assure_yaml(paths.repo / "etc" / "spack" / "config.yaml",
                                 config_dat)

        cfg_file("config.yaml", dict(config=config_dat))
                 


    def assure_repo_clone(self, name, recurs=True):
        '''
        Assure that repo of given name is cloned and at the right tag.

        A tag corresponds to a branch wcwc-<tag>
        '''
        repo = self.cfg['repos'][name]

        if recurs and repo.get("upstreams", ()):
            for usr in repo['upstreams']:
                self.assure_repo_clone(usr, True)

        paths = self.paths(name)

        def git(cli, *args, quiet=False, **kwds):
            kwds['cwd'] = paths.repo
            func = call if quiet else run
            cli = 'git ' + cli
            return func(cli, *args, **kwds)

        if not paths.repo.exists():
            url = repo['url']
            if not url:
                raise KeyError(f'no url for {name}')
            run(f"git clone {url} {paths.repo}")
        else:
            git("fetch")

        tag = repo.get("tag", None)
        if tag is None:
            return

        want_branch = f'wcwc-{tag}'
        have_branch = git("rev-parse --abbrev-ref HEAD", quiet=True)
        if have_branch == want_branch:
            return

        try:
            git(f'show-ref --verify --quiet refs/heads/{want_branch}', quiet=True)  # call to see if fails
        except:
            git(f'checkout -b {want_branch} {tag}')
        else:
            git(f'checkout {want_branch}')


def setup_logging(log_output, log_level):
    try:
        level = int(log_level)      # try for number
    except ValueError:
        level = log_level.upper()   # else assume label
    log.setLevel(level)

    if not log_output:
        log_output = ["stdout"]
    for one in log_output:
        if one in ("stdout", "stderr"):
            sh = logging.StreamHandler(getattr(sys, one))
            sh.setLevel(level)
            log.addHandler(sh)
            continue
        fh = logging.FileHandler(one)
        fh.setLevel(level)
        log.addHandler(fh)

    debug(f'logging to {log_output} at level {log_level}')

cmddef = dict(context_settings = dict(auto_envvar_prefix='WCWC',
                                      help_option_names=['-h', '--help']))
@click.option("-c", "--config", default=None, type=str,
              help="Specify a config file")
@click.option("-p", "--prefix", default=None, type=str,
              help="Specify WCWC Spack installation prefix (def=/wcwc)")
@click.option("-l","--log-output", multiple=True,
              help="log to a file [default:stdout]")
@click.option("-L","--log-level", default="info",
              help="set logging level [default:info]")
@click.group("wcwc", **cmddef)
@click.pass_context
def cli(ctx, config, prefix, log_output, log_level):
    setup_logging(log_output, log_level)
    ctx.obj = Config(prefix, config)


@cli.command("junk")
@click.option("-p", "--prefix", default=None, type=str)
@click.pass_context
def junk(ctx, prefix):
    '''
    Ignore this cmd, it is to test out click stuff.
    '''
    info(f'junk: {prefix=}')
    info(ctx.obj.cfg)


@cli.command("dump-config")
@click.pass_context
def dump_config(ctx):
    info (yaml.dump(ctx.obj.cfg, sort_keys=False))

@cli.command("status")
@click.pass_context
def status(ctx):
    for repo in ctx.obj.repos:
        paths = ctx.obj.paths(repo)
        git_dir = paths.git
        if git_dir.exists():
            ver = call(f'git --git-dir {git_dir} rev-parse --abbrev-ref HEAD').strip()
            info(f'{repo} {ver}')
        else:
            info(f'{repo} missing')

@cli.command("check-os")
def check_os():
    """Check if current running OS is supported"""
    got = call("lsb_release -ds").strip()
    if got in known_oses:
        return
    raise ValueError(f'not a supported OS: {got}')

@cli.command("list-oses")
def list_oses():
    '''
    Print names of supported operating systems, one per line.
    '''
    for one in known_oses:
        info(one)


@cli.command("spack", context_settings=dict(ignore_unknown_options=True,
                                            help_option_names=[]))
@click.option("--scope", default=os.environ.get('SPACK_USER_CONFIG_PATH', "base"),
              help="Set the spack scope by name, translates to -C/--config-scope directory")
@click.argument("args", nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def spack(ctx, scope, args):
    '''
    Wrapper around calling spack.
    '''
    args = list(args)
    if not ("-C" in args or "--config-scope" in args):
        if not "/" in scope:    # path
            scope = str(ctx.obj.paths(scope).scope)
        args = ["-C", scope] + args
    ctx.obj.spack(*args)
        

@cli.command("list-scopes")
@click.pass_context
def list_scopes(ctx):
    '''List known scopes'''
    for name, dat in ctx.obj.cfg['repos'].items():
        paths = ctx.obj.paths(name)
        url=dat.get('url','')
        tag=dat.get('tag','')
        us=','.join(dat.get('upstreams',[]))
        exist = "installed" if paths.scope.exists() else "missing"
        info(f'{name:12} {paths.scope} ({exist}) {tag}')

def use_repo(record = True):
    '''The command deals with a remote git repo'''
    def decorator(func):
        @click.option("-t","--tag",default=None, type=str, 
                      help=f"override default git tag")
        @click.option("-u","--url",default=None, type=str,
                      help=f"override default git url")
        @click.option("-U","--upstreams",default=None, type=str,
                      help=f"override upstreams (comma separated list)")
        @click.option("-n","--name",default="base", type=str,
                      help=f"give name of repo (default=base)")
        @click.pass_context
        @functools.wraps(func)
        def wrapper(ctx, tag, url, upstreams, name, *args, **kwds):
            ctx.obj.repo(name, record=record, tag=tag, url=url, upstreams=upstreams)
            kwds['name'] = name
            return func(*args, **kwds)
        return wrapper
    return decorator

@cli.command("install-repo")
@click.option("-r", "--recurs", is_flag=True, default=False,
              help="recurs over upstreams, if any (default=False)")
@click.option("-f","--force", is_flag=True, default=False,
              help="force overwriting (default=False)")
@use_repo()
@click.pass_context
def install_repo(ctx, recurs, force, name):
    '''
    Install the named repo.

    If recurs is True, upstreams with their default configuration will be installed.

    If the repo name is not known and is new then at least URL is required.
    '''
    ctx.obj.assure_repo(name, recurs, force)
    ctx.obj.save()
    


@cli.command("spack-setup")
@click.option("-s", "--shell",
              default="auto",
              type=click.Choice(["sh","bash","zsh","fish","csh","tcsh","auto"]),
              help="Set the shell flavor, default:auto")
@click.pass_context
def spack_setup(ctx, shell):
    '''
    Emit the Spack env script to source, possibly divining the shell.

    Note, do not log to stdout if you directly source the result.
    '''
    if ctx.obj.prefix != "/wcwc":
        if os.environ.get("WCWC_PREFIX",None) is None:
            sys.stderr.write(f"""\
I notice you are using a non-standard WCWC prefix.
To avoid giving --prefix define:
    WCWC_PREFIX="{ctx.obj.prefix}"
""")
        

    if shell == "auto":
        shell = os.environ.get("SHELL",None)
        if not shell:
            user = os.environ.get("USER", call("id -u -n"))
            shell = call(f"getent passwd {user}").split(":")[6]
        if not shell:
            raise ValueError("can not divine shell")
    shell = shell.split("/")[-1].strip()  #  if given as /path/to/shell

    ext = dict(sh="sh",bash="sh",zsh="sh",fish="fish",csh="csh",tcsh="csh")[shell]

    script = ctx.obj.paths("base").git.parent / "share" / "spack" / f"setup-env.{ext}"
    # This is a print, not log.  
    print(script)
    
@cli.command("devenv")
@click.option("-U","--upstreams",default=None, type=str,
              help=f"override upstreams (comma separated list)")
@click.argument("path")
@click.pass_context
def devenv(ctx, upstreams, path):
    '''
    Create a Spack environment based on one or more upstreams.

    Once activated, user can install packages to it.
    '''
    path = Path(path)

    spack_yaml = path / "spack.yaml"
    if spack_yaml.exists():
        debug(f'environment already exists at {path}')
    else:
        ctx.obj.spack(f'env create --dir {path}')

    upstreams = upstreams.split(",")
    if not upstreams:
        return
    upstreams = ctx.obj.resolve_upstreams(*upstreams)
    upstreams.reverse()


    dat = dict(upstreams=dict(), repos=list())
    for name in upstreams:
        paths = ctx.obj.paths(name)
        dat["upstreams"][name] = dict(install_tree=str(paths.install))
        dat["repos"].append(str(paths.repo))
    dat["config"] = dict(
        install_tree=dict(root=str(path / "install")),
        build_stage=[str(path / "stage")],
        source_cache=str(path / "cache"))

    old_dat = yaml.safe_load(spack_yaml.read_text())
    new_dat = merge_patch(old_dat, dict(spack=dat))
    print (new_dat)
    spack_yaml.write_text(yaml.dump(new_dat, sort_keys=False))


if '__main__' == __name__:
    cli()
