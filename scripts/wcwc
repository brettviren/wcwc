#!/usr/bin/env python
'''
Manage and use elements of a Wire-Cell Workstation Cluster.

It may take a configuration file given explicitly or defaulting to
<prefix>/wcwc.cfg.  The file <prefix>/wcwc.cfg will be rewritten to reflect
changes to the WCWC area under <prefix>/.
'''

default_repos = dict(
    base=dict(url="https://github.com/spack/spack.git", tag="v0.22.1"),
    wirecell=dict(url="https://github.com/WireCell/wire-cell-spack.git", tag="0.28.0.0", upstreams=["base"]),
    nusoft=dict(url="https://github.com/NuSoftHEP/nusofthep-spack-recipes.git", upstreams=["base"]),
    art=dict(url="https://github.com/FNALssi/fnal_art.git", upstreams=["nusoft"]),
    larsoft=dict(url="https://github.com/LArSoft/larsoft-spack-recipes.git", upstreams=["art"]),
    # dune, sbnd, ...
)

# These are lsb_release -ds lines from OSes that should work as WCWC members.
# In principle, WCWC can work on many OSes.  To extend this list, the
# "prepare-os" command would need extending and the typical Spack installations
# used for WCWC applications would need testing.
known_oses=("Debian GNU/Linux 12 (bookworm)",)


import os
import sys
import json
import yaml
import click
import shutil
import graphlib
import functools
from pathlib import Path
from collections import namedtuple

import logging
log = logging.getLogger("wcwc")
debug = log.debug
info = log.info
warn = log.warn
error = log.error


# Code may use parts of subprocess 
from subprocess import STDOUT, PIPE, CalledProcessError

def run(cmd, lines=None, capture_error=True, *args, **opts):
    '''
    Apply default policy to subprocess.run()

    If lines provides an integer, stdout is decoded to string and up to that
    many newline-delimited lines are returned instead of a CompletedProcess
    object.  The end of the string does NOT have a new line.

    If capture_error is true (default) then an error return code will lead to
    the stdout and stderr being logged prior to throwing.
    '''
    from subprocess import run as srun
    if isinstance(cmd, str):
        opts["shell"]=True
    opts.setdefault("capture_output", True)
    opts.setdefault("check", False)
    if capture_error:
        opts["check"] = False
    debug(f'exec: {cmd} {args} {opts}')
    rc = srun(cmd, *args, **opts)  # throws
    if capture_error and rc.returncode:
        error(f'command failed: {cmd}')
        out = rc.stdout.decode() if rc.stdout else ""
        error(f'output:\n{out}')
        err = rc.stderr.decode() if rc.stderr else ""
        error(f'error:\n{err}')
        rc.check_returncode()   # raise the exception

    if not lines:
        return rc
    return '\n'.join(rc.stdout.decode().strip().split("\n")[:lines])


def which(exe, def_cli=None, *def_args, **def_opts):
    '''
    Find program "exe" and return a function that is called like:

        func(cli=None, *args, **opts)

    When this function is called the exe is executed with addition command line
    args cli.

    If def_* are given to which(), they provide initial defaults that cli, args
    and opts amend.

    The cmd=exe+cli, args and opts are passed to run().
    '''
    path = shutil.which(str(exe))
    if path is None:
        raise FileNotFoundError(f'no such executable "{exe}"')
    
    def func(cli=None, *args, **opts):

        parts = [[path], def_cli, cli]
        if any([isinstance(p,str) for p in parts]):
            # any a string, all a string
            line = list()
            for i,p in enumerate(parts):
                if isinstance(p, str):
                    line.append(p)
                elif p:
                    line.append(' '.join(p))
            line = ' '.join(line)
        else:                   # no strings, only array
            line = []
            for p in parts:
                if p: line += list(p)

        if not args: args = list()
        args = def_args or list() + args

        if not opts: opts = dict()
        opts = def_opts or dict () | opts

        return run(line, *args, **opts)
    return func

def merge_patch(target, patch):
    '''
    Patch target and return result.

    https://datatracker.ietf.org/doc/html/rfc7396

    '''
    if isinstance(patch, dict):
        if not isinstance(target, dict):
            target = dict()
        for k,v in patch.items():
            if v is None:
                if k in target:
                    target.pop(k)
            elif k in target:
                target[k] = merge_patch(target[k], v)
            else:
                target[k] = v
        return target
    return patch


def merge_dicts(dict1, dict2):
    """ Recursively merges dict2 into dict1 """
    if not isinstance(dict1, dict) or not isinstance(dict2, dict):
        return dict2
    for k in dict2:
        if k in dict1:
            dict1[k] = merge_dicts(dict1[k], dict2[k])
        else:
            dict1[k] = dict2[k]
    return dict1


class Config:
    def __init__(self, prefix, config):
        self.prefix = Path(prefix or "/wcwc")
        self.cfg_path = Path(config or self.prefix / "wcwc.yml")
        self.cfg = dict(repos=default_repos)
        if self.cfg_path.exists():
            self.cfg = merge_dicts(self.cfg,
                                   yaml.safe_load(self.cfg_path.read_text()))

    @property
    def repos(self):
        '''Known repo names'''
        return self.cfg["repos"].keys()


    def depgraph(self, *seeds):
        gr = dict()
        for seed in seeds:
            gr[seed] = set(list(self.cfg['repos'][seed].get("upstreams",())))
            gr |= self.depgraph(*gr[seed])
        return gr
            

    def resolve_upstreams(self, *seeds):
        '''
        Resolve upstream dependencies to a flat list.
        '''
        gr = self.depgraph(*seeds)
        return list(graphlib.TopologicalSorter(gr).static_order())


    @functools.cached_property
    def spack_exe(self):
        return self.paths("base").root / "repo" / "bin" / "spack"

    def save(self):
        self.cfg_path.parent.mkdir(parents=True, exist_ok=True)
        self.cfg_path.write_text(yaml.dump(self.cfg, sort_keys=False))

    def repo(self, name, record=False, **kwds):
        '''
        Return a (git) repo dict with name, possibly overriding with kwds
        '''
        got = dict(self.cfg['repos'].get(name, {}))
        for key in "tag url upstreams".split():
            val = kwds.get(key, None)
            if val is None:
                continue
            got[key] = val
        if record:
            self.cfg['repos'][name] = got
        return got
        
    def assure_yaml(self, path, dat, force=False):
        path = Path(path)
        if path.exists() and not force:
            debug(f'not writing existing file: {path}')
            return
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(yaml.dump(dat, sort_keys=False))
        debug(f'wrote file: {path}')

    def paths(self, name):
        '''
        Return all canonical paths for repo.
        '''
        root = self.prefix / "spack" / name
        more = {k:root/k for k in "scope repo install environments".split()}
        more['git'] = root / "repo" / ".git"
        if name == "base":
            # Connect with Spack's structure that differs from how WCWC handles
            # others.  "repo" refers to Spack repo not git repo though these two
            # coincide for the "chained" repos.
            more['repo'] = more['repo'] / "var" / "spack" / "repos" / "builtin"
        return namedtuple("Paths", "root scope repo install environments git")(root=root, **more)


    def assure_stack(self, name, recurs=False, force=False):
        '''
        Assure a repo is configured.
        '''
        self.assure_stack_clone(name, recurs)
        self.assure_stack_scope(name, recurs, force)

    def assure_stack_scope(self, name, recurs=False, force=False):
        '''
        Assure that a repo scope is configured.
        '''
        repo = self.cfg['repos'][name]

        if recurs and repo.get("upstreams", ()):
            for usr in repo['upstreams']:
                self.assure_stack_scope(usr, True)

        paths = self.paths(name)

        def cfg_file(fname, dat):
            self.assure_yaml(paths.scope / fname, dat, force)

        cfg_file("repos.yaml", dict(repos=[str(paths.repo)]))

        config_dat = dict(build_stage=['$user_cache_path/stage'],
                          install_tree=dict(root=str(paths.install)),
                          environments_root=str(paths.environments))
        
        ups = repo.get("upstreams", None)
        if ups:
            upstreams = dict()
            for usr in ups:
                upstreams[usr] = dict(install_tree = str(self.paths(usr).install))
                
            #config_dat['upstreams'] = upstreams
            cfg_file("upstreams.yaml", dict(upstreams=upstreams))
            

        if name == "base":
            # Hack: make sure bare spack repo is configured like base.
            if paths.repo.exists():
                # git would get angry if we run this before assure_repo_clone....
                self.assure_yaml(paths.repo / "etc" / "spack" / "config.yaml",
                                 config_dat)

        cfg_file("config.yaml", dict(config=config_dat))
                 


    def assure_stack_clone(self, name, recurs=True):
        '''
        Assure that repo of given name is cloned and at the right tag.

        A tag corresponds to a branch wcwc-<tag>
        '''
        repo = self.cfg['repos'][name]

        if recurs and repo.get("upstreams", ()):
            for usr in repo['upstreams']:
                self.assure_stack_clone(usr, True)

        paths = self.paths(name)

        git = which("git", cwd=paths.repo)

        if not paths.repo.exists():
            url = repo['url']
            if not url:
                raise KeyError(f'no url for {name}')
            run(f"git clone {url} {paths.repo}")
        else:
            git("fetch")

        tag = repo.get("tag", None)
        if tag is None:
            return

        want_branch = f'wcwc-{tag}'
        have_branch = git("rev-parse --abbrev-ref HEAD")
        if have_branch == want_branch:
            return

        try:
            git(f'show-ref --verify --quiet refs/heads/{want_branch}')  # call to see if fails
        except:
            git(f'checkout -b {want_branch} {tag}')
        else:
            git(f'checkout {want_branch}')


def setup_logging(log_output, log_level):
    try:
        level = int(log_level)      # try for number
    except ValueError:
        level = log_level.upper()   # else assume label
    log.setLevel(level)

    if not log_output:
        log_output = ["stdout"]
    for one in log_output:
        if one in ("stdout", "stderr"):
            sh = logging.StreamHandler(getattr(sys, one))
            sh.setLevel(level)
            log.addHandler(sh)
            continue
        fh = logging.FileHandler(one)
        fh.setLevel(level)
        log.addHandler(fh)

    debug(f'logging to {log_output} at level {log_level}')

cmddef = dict(context_settings = dict(auto_envvar_prefix='WCWC',
                                      help_option_names=['-h', '--help']))
@click.option("-c", "--config", default=None, type=str,
              help="Specify a config file")
@click.option("-p", "--prefix", default=None, type=str,
              help="Specify WCWC Spack installation prefix (def=/wcwc)")
@click.option("-l","--log-output", multiple=True,
              help="log to a file [default:stdout]")
@click.option("-L","--log-level", default="info",
              help="set logging level [default:info]")
@click.group("wcwc", **cmddef)
@click.pass_context
def cli(ctx, config, prefix, log_output, log_level):
    setup_logging(log_output, log_level)
    ctx.obj = Config(prefix, config)


@cli.command("junk")
@click.option("-p", "--prefix", default=None, type=str)
@click.pass_context
def junk(ctx, prefix):
    '''
    Ignore this cmd, it is to test out click stuff.
    '''
    info(f'junk: {prefix=}')
    info(ctx.obj.cfg)


@cli.command("dump-config")
@click.pass_context
def dump_config(ctx):
    info (yaml.dump(ctx.obj.cfg, sort_keys=False))

@cli.command("status")
@click.pass_context
def status(ctx):
    git = which("git")

    for repo in ctx.obj.repos:
        paths = ctx.obj.paths(repo)
        git_dir = paths.git
        if git_dir.exists():
            ver = git(f'--git-dir {git_dir} rev-parse --abbrev-ref HEAD', lines=1)
            info(f'{repo} {ver}')
        else:
            info(f'{repo} missing')

@cli.command("check-os")
def check_os():
    """Check if current running OS is supported"""
    got = run("lsb_release -ds", lines=1)
    if got in known_oses:
        return
    raise ValueError(f'not a supported OS: {got}')

@cli.command("list-oses")
def list_oses():
    '''
    Print names of supported operating systems, one per line.
    '''
    for one in known_oses:
        info(one)


@cli.command("spack", context_settings=dict(ignore_unknown_options=True,
                                            help_option_names=[]))
@click.option("--stack", default=os.environ.get('SPACK_USER_CONFIG_PATH', "base"),
              help="Set the 'stack' by name, translates to -C/--config-scope directory")
@click.argument("args", nargs=-1, type=click.UNPROCESSED)
@click.pass_context
def spack(ctx, stack, args):
    '''
    Wrapper around calling spack.
    '''
    args = list(args)
    if not ("-C" in args or "--config-scope" in args):
        if not "/" in stack:    # convert to scope path
            scope_path = str(ctx.obj.paths(stack).scope)
        else:
            scope_path = stack
        args = ["-C", scope_path] + args
    exe = which(ctx.obj.spack_exe, capture_error=False, capture_output=False, check=False)
    got = exe(args)
    rc = sys.exit(got.returncode)
    sys.exit(rc.returncode)

@cli.command("list-scopes")
@click.pass_context
def list_scopes(ctx):
    '''List known scopes'''
    for name, dat in ctx.obj.cfg['repos'].items():
        paths = ctx.obj.paths(name)
        url=dat.get('url','')
        tag=dat.get('tag','')
        us=','.join(dat.get('upstreams',[]))
        exist = "installed" if paths.scope.exists() else "missing"
        info(f'{name:12} {paths.scope} ({exist}) {tag}')

def use_repo(record = True):
    '''The command deals with a remote git repo'''
    def decorator(func):
        @click.option("-t","--tag",default=None, type=str, 
                      help=f"override default git tag")
        @click.option("-u","--url",default=None, type=str,
                      help=f"override default git url")
        @click.option("-U","--upstreams",default=None, type=str,
                      help=f"override upstreams (comma separated list)")
        @click.option("-n","--name",default="base", type=str,
                      help=f"give name of repo (default=base)")
        @click.pass_context
        @functools.wraps(func)
        def wrapper(ctx, tag, url, upstreams, name, *args, **kwds):
            ctx.obj.repo(name, record=record, tag=tag, url=url, upstreams=upstreams)
            kwds['name'] = name
            return func(*args, **kwds)
        return wrapper
    return decorator

@cli.command("install-stack")
@click.option("-r", "--recurs", is_flag=True, default=False,
              help="recurs over upstreams, if any (default=False)")
@click.option("-f","--force", is_flag=True, default=False,
              help="force overwriting (default=False)")
@use_repo()
@click.pass_context
def install_stack(ctx, recurs, force, name):
    '''
    Install the spack support for the named stack.

    If recurs is True, upstreams with their default configuration will be installed.

    If the stack name is not known and is new then at least URL is required.

    No actual packages are installed.
    '''
    ctx.obj.assure_stack(name, recurs, force)
    ctx.obj.save()
    


@cli.command("spack-setup")
@click.option("-s", "--shell",
              default="auto",
              type=click.Choice(["sh","bash","zsh","fish","csh","tcsh","auto"]),
              help="Set the shell flavor, default:auto")
@click.pass_context
def spack_setup(ctx, shell):
    '''
    Emit the Spack env script to source, possibly divining the shell.

    Note, do not log to stdout if you directly source the result.
    '''
    if ctx.obj.prefix != "/wcwc":
        if os.environ.get("WCWC_PREFIX",None) is None:
            sys.stderr.write(f"""\
I notice you are using a non-standard WCWC prefix.
To avoid giving --prefix define:
    WCWC_PREFIX="{ctx.obj.prefix}"
""")
        

    if shell == "auto":
        shell = os.environ.get("SHELL",None)
        if not shell:
            user = os.environ.get("USER", run("id -u -n", lines=1))
            shell = run(f"getent passwd {user}", lines=1).split(":")[6]
        if not shell:
            raise ValueError("can not divine shell")
    shell = shell.split("/")[-1].strip()  #  if given as /path/to/shell

    ext = dict(sh="sh",bash="sh",zsh="sh",fish="fish",csh="csh",tcsh="csh")[shell]

    script = ctx.obj.paths("base").git.parent / "share" / "spack" / f"setup-env.{ext}"
    # This is a print, not log.  
    print(script)
    
@cli.command("devenv")
@click.option("-U","--upstreams",default=None, type=str,
              help="override upstreams (comma separated list)")
@click.argument("path")
@click.pass_context
def devenv(ctx, upstreams, path):
    '''
    Create a Spack environment with associated upstreams.

    Once activated, packages may be installed.
    '''

    path = Path(path).absolute()
    if path.exists():
        debug(f'devenv: exists at {path}')
    else:
        sexe = which(ctx.obj.spack_exe)
        sexe(f'env create --dir {path}')

    spack_yaml = path / "spack.yaml"

    dat = dict()

    if upstreams:
        upstreams = upstreams.split(",")
        upstreams = ctx.obj.resolve_upstreams(*upstreams)
        upstreams.reverse()

        dat["upstreams"] = dict()
        dat["repos"] = list()
        for name in upstreams:
            paths = ctx.obj.paths(name)
            dat["upstreams"][name] = dict(install_tree=str(paths.install))
            dat["repos"].append(str(paths.repo))

    dat["config"] = dict(
        install_tree=dict(root=str(path / "install")),
        build_stage=[str(path / "stage")],
        source_cache=str(path / "cache"))

    old_dat = yaml.safe_load(spack_yaml.read_text())
    new_dat = merge_patch(old_dat, dict(spack=dat))
    spack_yaml.write_text(yaml.dump(new_dat, sort_keys=False))
    debug(f"devenv made at {path.absolute()} with upstreams {upstreams}")
    info(f'Activate with:\n\tsource `wcwc spack-setup`\n\tspack env activate {path.absolute()}')

if '__main__' == __name__:
    cli()
